.. _record-copies:

Designing Record Copy Semantics to Support Arrays
=================================================

Status:
  Draft

Authors:
  Michael Ferguson

Abstract
--------

Introduction
------------

This CHIP seeks to solve the problem of array memory management in
Chapel. This is an important problem because any array memory leak limits
the usefulness of the Chapel language. At the same time, since arrays
are frequently used in Chapel programs, overhead of managing their memory
impacts the performance of most Chapel programs. Lastly, this issue cuts
accross language design, compiler implementation, and module code
implementation.

The current implementation uses array reference counting but that is no
longer necessary because of changes in the language (see
http://chapel.cray.com/docs/latest/language/evolution.html#lexical-scoping ).

While there is general agreement that arrays no longer need reference
counting, the current semantics make this changing this strategy
challenging. A simple strategy would be to treat arrays in a similar
manner to strings - each array variable is freed when it goes out of
scope and copy causes the array elements to be copied into separate memory.
Problems with this approach include:

 * arrays currently return by reference and some idioms depend on this
   property for performance
 * returning a slice of a local array is an important idiom
   that needs to continue to work

This CHIP describes an approach to implement arrays using records that
overcomes these challenges. These arrays will be freed when they go out of
scope and do not need to include reference counting. In order to make this
approach work, this CHIP proposes adjustments to the currently implemented
behavior of both records and arrays.

Existing Approach
+++++++++++++++++

The existing approach to manage array memory is to implement arrays in
terms of records and classes. These record implementing arrays is called
`_array` and it consists mainly of a pointer to a class instance. Thus
this strategy might be called a `record-wrapped class`. The `_array`
record receives some special treatment within the compiler. The
implementation works with autoCopy, initCopy, and autoDestroy. While
these three functions apply to user records as well, at the moment we are
interested in when they are added for `_array`.

 * autoCopy is called when returning a global array or when passing an array to
   a task function
 * initCopy is called when assigning an array to a user-level variable
 * autoDestroy is called when an array variable goes out of scope

In the current implementation, autoCopy initializes a new array variable
to point to the same array elements but increments a reference count for the
array elements.  initCopy allocates new array elements and initializes it with
the old array and sets the reference count for the new array elements to 1.
autoDestroy decrements the reference count for the array elements and frees
the array elements if it reaches 0.

The current implementation of array memory management has some drawbacks:

 * it leaks memory for distributed arrays
 * reference counting is no longer semantically necessary
 * it adds more copies than are strictly necessary
 * program performance depends on whether or not the user gives
   a name to an expression

The example below helps to discuss the last two points. It causes two copy
initializations where other languages might implement the same pattern without
any copies.

.. code-block:: chapel

  proc returnArray() {
    var A:[1..10] int;
    return A;
  }

  proc returnReturnArray() {
    var B = returnArray();     // var B = call() causes initCopy()
    return B;
  }

  var C = returnReturnArray(); // var C = call() causes initCopy()
  writeln(C);

Confusingly, adjusting `returnReturnArray` to consist of just `return
returnArray()` causes the program to generate one fewer initCopy() call.

Function Return Behavior
++++++++++++++++++++++++

In Chapel 1.13, records and arrays have different behavior when returned from a
function. In particular, records return by value - but arrays return by
reference. The following example shows the issue.

.. code-block:: chapel

  record R {
    var element:int;
  }

  var globalArray:[1..1] int;
  var globalRecord:R;

  proc returnArray() {
    return globalArray;
  }
  proc returnRecord() {
    return globalRecord;
  }

  writeln("globalArray is ", globalArray);
  writeln("setting returnArray()[1] to 2");

  returnArray() = otherArray;
  // or, equvalently returnArray()[1] = 2;
  // both of these statements end up modifying globalArray

  writeln("globalArray is now ", globalArray);

  writeln(globalArray);

  writeln("globalRecord is ", globalRecord);
  writeln("setting returnRecord().element to 3");

  //returnRecord() = otherRecord; // compile error: illegal lvalue in assignment

  // here is a similar statement that currently compiles
  // and which does not modify globalRecord.
  returnRecord().element = 2;

  writeln("globalRecord is now ", globalRecord);

The above program has output

::

  globalArray is 0
  setting returnArray()[1] to 2
  globalArray is now 2
  2
  globalRecord is (element = 0)
  setting returnRecord().element to 3
  globalRecord is now (element = 0)

This output indicates that modifying the array returned from `returnArray`
causes a modification to `globalArray` - in other words, the array elements
are returned by reference. In contrast, modifying the value returned by
`returnRecord` does not result in a modification to `globalRecord`.  The record
is returned by value.

The current language specification indicates that `returnArray` and
`returnRecord` should return by value. Spec version 0.981, section 13.7
says "By default, or if the return-intent is const, the function returns
a value that cannot be used as an lvalue". That statement indicates that
the statement `returnArray() = otherArray` should be an error just as
`returnRecord() = otherRecord` is. It is less clear what it means for the
versions setting an element, such as returnArray()[1] = 2.

Thus, the current behavior for returning arrays does not appear to match
the specification.

.. commented-out

  Section 20.2 says "Chapel semantics are defined so that the compiler
  will never need to insert temporary arrays of the same size as a user
  array variable."

Note though that in Chapel, both arrays and records are `value types` in that
when you initialize one variable with another, the elements are copied. E.g.

.. code-block:: chapel

  var A:[1..1] int;
  var B = A;        // initializes B to a copy of A
  B[1] = 1;
  writeln(A[1]);

outputs `0` because `B` is initialized to a copy of `A`. Compare with a class
type - which is not a value type. There, a similar program would output 1.


Strawman Proposal
+++++++++++++++++

A strawman proposal helps to identify some of the key issues with array
copy initialization. Consider a strawman strategy for implementing arrays
in which they are function similarly to strings:

 * arrays return by value (unless the const ref or ref return intent is
   specified) since that is the behavior for user records
 * autoDestroy frees the array elements, so that array elements are freed
   whenever that array goes out of scope 
 * initCopy copies of the array elements, so that each different variable
   refers to separate memory and can be independently freed.

Such an approach would run into these several challenges. Three examples
demonstrate the issues.

.. _record-copies-strawman-consume-return:

Passing a Call Result into a Function
*************************************

.. code-block:: chapel

  proc returnArray() {
    var A:[1..10] int;
    return A;
  }

  proc consumeArray(A) {
    writeln(A[1]);
  }

  consumeArray(returnArray());

This example is simple enough that it should probably continue to work.
However, since the blank argument intent for an array indicates `ref` argument
intent, if `returnArray` returns `const`, it would be a compiler error since
something that is not an lvalue cannot be passed as a `ref` argument.

.. _record-copies-strawman-xform:

Array Transformation Idiom
**************************

.. code-block:: chapel

  proc xform(arg) {
    arg[1] += 1;
    return arg;
  }

  config const n = 100000;
  var A:[1..n] int;
  var B = xform(xform(xform(A)));

This example shows a potential performance problem for one idiom for
transforming an array in a function call. If arrays return by value, each xform
call would create a new copy of the array. At the same time, the current
behavior adds only one copy of the array elements when initializing B.

.. _record-copies-strawman-return-slice:

Returning a Slice of a Local Array
**********************************

.. code-block:: chapel

  proc f() {
    var A:[1..4] int;
    return A[2..3];
  }

  var A_slice = f();
  writeln(A_slice);

This example program is currently valid and it is desireable that it
continue to function. However, under the strawman proposal, the slice
construction A[2..3] would result in a record that points to the same
array elements as `A`.  These array elements will be freed at the end of
`f` when `A` goes out of scope. Subsequent use of the value returned -
including to initialize `A_slice` - will access invalid memory and
potentially cause program failure.


Description
-----------

Summary of Approach
+++++++++++++++++++

This CHIP seeks to show how arrays can be implemented with
`record-wrapped class`.  It does this in three steps. First, it discusses
the concepts of `copy initialization` and `move initialization`. Then, it
proposes rules all records - including the records implementing arrays -
that indicate when `copy initialization` and `move initialization` occur.
Finally, it describes how these rules support an implementation of arrays
in terms of records that does not require reference counting.

The separate document :ref:`record-copies-examples` discusses how the rules
described in this document enable other use cases for records.  The documents
:ref:`record-copies-out-inout` and :ref:`record-copies-expiring` discuss
improvements to the rules described in this proposal.

Lastly, this document will ignore the issues around run-time types for
arrays in order to simplify the description. The document
:ref:`record-copies-runtime-types` discusses how runtime types interact
with this design.

Preliminaries
+++++++++++++

Record Initialization and Destruction
*************************************

Record initialization and destruction are described in CHIP 10.  For the
purposes of this document, it suffices to know that records are destroyed
when they go out of scope and at that time a `deinit` method is called.
A typical `deinit` method would free memory used by a pointer field.

Copy and move concepts
**********************

This proposal uses the terminology `copy` and `move`. These terms
describe how a Chapel program initializes a record variable based upon an
existing record variable. Both `copy` and `move` create a new variable
from an initial variable.

After the `copy` initialization, both the new variable and the initial
variable exist separately. Generally speaking, they can both be modified.
However, they must not refer to the same fields. That is, changing a
field in the new record variable should not change the corresponding
field in the initial record variable.

A `move` is when a record variable changes storage location. It is
similar to a `copy` initialization but it represents a transfer rather than
duplication. In particular, the initial record is no longer available
after the `move`.  A `move` can be thought of as an optimized form a
`copy` followed by destruction of the initial record.  After a `move`,
there is only one record variable - where after a `copy` there are two.

Record authors can adjust copy and move
***************************************

Record authors can specify code to run on a `copy`.  For example, a record that
contains a pointer to a class instance can operate as though the fields in the
class instance were stored directly in the record by copying the class instance
in each record `copy` initialization. If a customizeable `copy` were not
available, the record author would be forced to support the case where two
record variables point to the same class instance - or to require that users of
that record include explicity `clone` method calls (for example).

Different languages make a different choice here. C++ and D allow record
authors to implement some part of a `copy`, but Rust and Swift do not.

Record authors can also customize a `move`. In particular, it allows
record authors to better control aliasing for pointer fields. This
feature is important for handling the issue discussed in the strawman
proposal :ref:`record-copies-strawman-return-slice`.


.. _record-copies-postblit-tbd:

Strategy for Customizing `copy` and `move` TBD
**********************************************

Note that at the time of this writing, specific syntax for how a record
can customize `copy` and `move` is still under discussion. The exact
choice does not matter for the question of *when* the compiler adds
`copy` or `move` initialization. However, concrete examples in this
document will use `postblit` and `postmove` as the methods that respond
to `copy` and `move` respectively. With a `postblit` strategy, these
methods are called after a shallow copy is made, e.g. a copy
initialization might consist of:

.. code-block:: chapel

  memcpy(dst, src)
  dst.postblit();

Similarly, a move initialization might consist of

.. code-block:: chapel

  memcpy(dst, src)
  dst.postmove();

The main alternative is to use `proc init` for copy and move
initialization.  In that case, a copy initialization might consist of:

.. code-block:: chapel

  dst.init(src);

How `move` initialization would be customized under the alternative is
also TBD.

Copy and move initialization
****************************

Record copy semantics in Chapel are a combination of two factors.

 1) The compiler adds `copy` or `move` initialization
 2) The record author implements certain methods
    to specify how the record should react to `copy` or `move`.

Copy initialization
^^^^^^^^^^^^^^^^^^^

The document :ref:`initialization` provides a canonical example of
when `copy initialization` occurs:

.. code-block:: chapel

  var x:R = ...;
  var y:R = x;    // copy initialization occurs here
  ... uses of both x and y ...;

The `postblit` method
^^^^^^^^^^^^^^^^^^^^^

Note that this section discusses one possible approach and has
not been finalized. See :ref:`record-copies-postblit-tbd`.

A record specifies how it reacts to a copy by providing a `postblit`
method. At the time that the `postblit` method is called, the `this`
variable is already initialized to a shallow copy. The `postblit` method
is responsible for performing a fixup.

.. code-block:: chapel

  class C {
    var a:int;
  }
  record R {
    var ptr:C;
  }
  proc R.postblit() {
    // Fix up for copy
    // e.g. copy a buffer that should not be shared between instances
    this.ptr = new C(a=this.ptr.a);
  }

If no `postblit` method is provided for a record, the compiler provides
one. The compiler-provided `postblit` method calls the `postblit` method
on each record field in turn.

Move initialization
^^^^^^^^^^^^^^^^^^^

Here is an example of when the compiler uses `move` initialization under
this proposal:

.. code-block:: chapel

  record R { ... }
  proc makeR() {
    return new R(...);
  }
  var x = makeR();    // move initialization occurs here


The `postmove` method
^^^^^^^^^^^^^^^^^^^^^

Note that this section discusses one possible approach and has not been
finalized. See :ref:`record-copies-postblit-tbd`.

A record can use a `postmove` method to react to a `move` initialization.  As
with `postblit`, the `this` variable is already initialized with a
shallow copy at the time that the `postmove` method is called. However,
in contrast to the `postblit` method, the initial record variable is destroyed
by the `move` initialization.

If no `postmove` method is provided for a record, the compiler provides
one. The compiler-provided `postmove` method calls the `postmove` method
on each record field in turn.


Rules for when copy or move initialization occur
++++++++++++++++++++++++++++++++++++++++++++++++

The following sections of this document describe situations in which a `copy`
or a `move` is added by the compiler to implement some kind of initialization.
Now, it might seem that the compiler could choose a variety of strategies to
implement one of these initializations. In particular, copy initialization
could be default-initialization followed by assignment. Likewise, move
initialization could be copy initialization followed by destruction of the
source variable.

This proposal takes the position that the language needs to provide a minimum
level of optimization and also provide some reproducability in this area.
Therefore, the semantics described below should be interpreted to be the
behavior the Chapel compiler provides in a baseline configuration (e.g. with
`--baseline`).

It may or may not be worthwhile to allow the compiler to further optimize
these cases, by replacing some `copy` initializations with `move`
initialization. On the one hand, there is an advantage to making programs
always behave the same in this regard. On the other, allowing some
flexibility here can allow programs to perform better and still operate
as expected.

This is a complicated issue because it impacts how Chapel users can
understand Chapel programs. If further optimization is allowed, it either
needs to be documented in detail in the language specification and always
applied - or, the language specification needs to be somewhat vague about
when `copy` or `move` is used.

We discuss how to present these record semantics to users in
:ref:`record-copies-user-view`. We discuss one optimization that could be
applied in :ref:`record-copies-expiring`. 


.. _copy-move-table:

When one record variable is initialized from another, the compiler must choose
whether to perform `copy initialization` or `move initialization`.

The following table shows in which situations a copy or move initialization is
added. Each row in this table corresponds to a particular use of an expression
`<expr>`. Each column indicates the kind the expression `<expr>`. Blank spaces
indicate that no copy or move initialization is necessary.

Here is the table for pre-1.13:

auto = autoCopy
init = initCopy

========================  ==========  =========  =========  ============  ============
operation                 value call  local var  outer var  ref argument  ref/ref call
========================  ==========  =========  =========  ============  ============
variable initialization   init        init       init       init          init     
call as `in` argument     auto+init   init       init       init          init    
field initialization      auto+auto   auto       auto       auto          auto
value return              auto+auto   auto       auto       auto          auto    
========================  ==========  =========  =========  ============  ============

Here is the table for strings/user records after 1.13:

========================  ==========  =========  =========  ============  ============
operation                 value call  local var  outer var  ref argument  ref/ref call
========================  ==========  =========  =========  ============  ============
variable initialization               init       init       init          init     
call as `in` argument     init        init       init       init          init    
field initialization      auto        auto       auto       auto          auto     
value return                                     auto       x?            auto    
========================  ==========  =========  =========  ============  ============

*value return, ref argument case seems to be an ommission* 
code in callDestructors seems to treat it, but string7.chpl shows
error/core dump.

Here is Plan B:

========================  ===========  =========  ===========  ============  ============
operation                 value call   local var  outer var    ref argument  ref/ref call
========================  ===========  =========  ===========  ============  ============
variable initialization   unalias      copy       copy         copy          copy     
call as `in` argument     unalias      copy       copy         copy          copy
cls field initialization  unalias      copy       copy         copy          copy     
r/t field initialization  alias        alias      alias        alias         alias
value return              onRet        onRet      alias/onRet  alias/onRet   alias/onRet  
========================  ===========  =========  ===========  ============  ============

copy = initCopy
alias = autoCopy

newArray(tok) -> set this.scopeToken = tok
unalias       -> if this.owned==false || this.isslice { this.ptr = this.ptr.clone(); this.owned = true; }
alias         -> owned=false; dst.scopeToken = src.scopeToken; dst.ptr = src.ptr;
onRet(tok)    -> if (this.owned == false || this.isslice ) && this.scopeToken == tok { this.ptr = this.ptr.clone(); this.owned = true; }

  -> default copy/initCopy calls copy/initCopy on fields
  -> default alias/autoCopy calls alias/autoCopy on fields
  -> default unalias calls unalias on fields
  -> default onret calls onret on fields

Q: field initialization seems pretty different...

Here is alternative described in this document:

========================  ==========  =========  =========  ============  ============
operation                 value call  local var  outer var  ref argument  ref/ref call
========================  ==========  =========  =========  ============  ============
variable initialization   move        copy       copy       copy          copy     
field initialization      move        copy       copy       copy          copy     
call as `in` argument     move        copy       copy       copy          copy
value return              move        move       copy (1)   copy (1)      copy
========================  ==========  =========  =========  ============  ============


(1) copy on value return can be skipped according to
:ref:`automatic-ref-return`.

Here is more detail on each operation:


variable initialization
  a variable initialization statement as in

  .. code-block:: chapel

    var a=<expr>;

field initialization
  a field initialization statement from Phase 1 of an initializer, as in

  .. code-block:: chapel

    record MyRecord {
      var field:R;

      proc init(...) {
        field = <expr>;
        super.init();
      }
    }


call as `in` argument
  a function call where `<expr>` corresponds to a formal with `in`
  intent, as in

  .. code-block:: chapel

    proc f(in arg) { ... }
    f(<expr>)

value return
  a return statement in a function that returns `by value` - that is,
  does not have `ref` or `const ref` return intent.

  .. code-block:: chapel

    proc f() {
      return <expr>;
    }

ref return
  a return statement in a function that returns `by ref` - that is, with
  `ref` or `const ref` return intent.

  .. code-block:: chapel

    proc g() ref {
      return <expr>;
    }

call as `ref` argument
  a function call where `<expr>` corresponds to a formal with `ref`
  or `const ref` intent (or in cases where blank intent is `ref` or
  `const ref`), as in

  .. code-block:: chapel

    proc f(ref arg) { ... }
    f(<expr>)


Here is more detail on each expression type. The examples below include
some supporting code and then have the form of `... <expr> ...`.

value call
  a call to a function that returns `by value` - that is, does not
  have `ref` or `const ref` return intent.
 
  .. code-block:: chapel

    proc f() { ... }

    ... f() ...;

local var
  a use of a variable local to a function
 
  .. code-block:: chapel

    proc f() {
      var x = ...;
      ... x ...;
    }

outer var
  a use of a variable not local to a function, including a global
  variable or a variable declared in an outer function.
 
  .. code-block:: chapel

    var global:R = ...;
    proc f() {
      ... global ...;
    }

ref argument
  a use of a formal argument that has the `ref` or `const ref` intent
  (or a blank intent that is `ref` or `const ref`).
 
  .. code-block:: chapel

    proc f(const ref arg) {
      ... arg ...;
    }

ref/ref call
  a use of a ref variable or a call returning with `ref` or `const ref`
  return intent.
 
  .. code-block:: chapel

    ref x = ...;
    ... x ...;

  .. code-block:: chapel

    proc g() ref { ... }
    ... g() ...;



.. _ref-return:

`ref` Return Intent
+++++++++++++++++++

The `ref` or `const ref` return intent indicates that unlike a normal
return, the returned value does not transfer the responsibility for
freeing something to the caller.  In other words, returning something by
`ref` does not change when that variable is destroyed.

Return statements inside a function with `ref` or `const ref` return
intent have the following behavior:

 * The `return` statement in a `ref` or `const ref` return intent
   function does not cause a `move` or `copy` initialization to be added. The
   `retVar` is just set to a created reference.
 * unlike non - `ref` returns, coercions and promotions are disabled for
   a ref return intent function. The type of the returned expression must
   match exactly. (This constraint is already described in the language
   specification);
 * it is a program error to return a reference to a value with a type 
   that is different from a function's declared return type.
   This should be flagged as a compile error or an execution-time error.
 * Returning a local variable or temporary in a function with `ref`
   return intent does not prevent that variable or temporary from being
   destroyed and so should be a compile error if possible. In other
   words, it is a program error to return a ref to any variable that is
   allocated on the stack. It is a program error in a ref-return function
   to:

   * directly return a local variable declared by the user.  This can be
     detected with a compiler error.
   * directly return a ref to a call to a function that does not have
     `ref` or `const ref` return intent because that returned value will
     be stored in a function-local temporary. This can be detected with a
     compile error.
   * return a reference to any value that will be destroyed once the
     function exits. It would be difficult for compiler analysis to find
     all such cases.

   
.. _automatic-ref-return:

Automatic `ref` Return Intent
+++++++++++++++++++++++++++++

The table above showed `copy/move` for two value return cases:

 * returning an outer variable
 * returning a ref argument

In these cases, it would be legal to use a `copy` initialization. However, in
some situations, the `copy` is unnecessary and oculd be removed by adding
the `ref` or `const ref` return intent to the function.

For example, consider this program:

.. code-block:: chapel

  record R { ... }
  var global:R = ...;

  proc f() {
    return global;
  }

  writeln(f());

This program causes the record `global` to be copied in the process of
being output, since it is copied during the process of returning from
`f`.  This copy is unnecessary in this example and could be optimized
away. A user might explicitly remove the copies by adding the `const ref`
return intent to `f`.

A further example is this program discussed in
:ref:`record-copies-strawman-xform`:

.. code-block:: chapel

  proc xform(arg) {
    arg[1] += 1;
    return arg;
  }

  config const n = 100000;
  var A:[1..n] int;
  var B = xform(xform(xform(A)));

Note that if `arg` had the `in` intent, the rules above would optimize
away the copies. However, when `arg` has the blank or `ref` intent,
the copies can be removed by adding the `ref` return intent to
`xform` - which the rule in this section will do. 

Both of these programs will not have unnecessary copies because of the
rule described in this section.

The `ref` or `const ref` return intent is added automatically for
functions that always:

  * return a formal argument, where the formal had `ref` or `const ref`
    intent, or
  * return a outer scope variable

The new return intent should match the default argument intent. For user
records, that is `const ref`, but for arrays, it would be `ref`.

Note that it is important to restrict this rule to ref arguments and
outer variables.  It would not in general be valid for this rule to apply
to all functions that always return a ref expression. For example, in the
following:

.. code-block:: chapel

  record R { var x:int; }
  proc f() {
    var a = new R(12);
    ref refA = a; 
    return refA; 
  }

  writeln(f());

the value returned in `f` is always a reference, but it would make the
program erroneous to add the `const ref` return intent to it.

TODO
----

* describe `inout` and `out` argument intents

.. _record-copies-arrays:

Implementing Arrays with a Record-Wrapped Class
+++++++++++++++++++++++++++++++++++++++++++++++

This section describes how Chapel arrays can be implemented based upon
the rules described above.

Recall that, for the purposes of exposition, this document ignores
runtime types. The document :ref:`record-copies-runtime-types` will
discuss how this design works with runtime types.

Recall that this document is proposing a strategy for implementing array
memory management using wrapper records. As with the current
implementation, this strategy consists of two types that work together:

 1) A wrapper record which is currently called `_array`
 2) a subclass of `BaseArr`, such as `DefaultRectangularArr`.
    
The wrapper record contains a field pointing to an object that is a
subtype of `BaseArr`. The object in turn stores the size of the array and
a pointer to the array elements.

Thus, the `_array` record might be defined as:

.. code-block:: chapel

  record _array {
    var _value;       // pointer to a subclass of BaseArr 
  }

For exposition purposes, we will also discuss a subclass of BaseArr
implementing a 1-D zero-based array. This helps to make the design
presented more concrete but ignores many details that real subclasses of
BaseArr need to attend to.

This proposal also requires that the each BaseArr subclass contain an
`isalias:bool` field in addition to the current fields. This field
supports array aliases and slices.

.. code-block:: chapel

  class SimpleArr : BaseArr {
    type eltType;                  // the type of an element
    var n: int;                    // the number of elements in the array
    var elements: _ddata(eltType); // pointer to the array elements
    var isalias:bool;              // supporting aliases and slices
  }

To implement Chapel's array semantics, we need to describe how the
`_array` wrapper record will respond to `copy` and `move` initialization.
We do that by defining its `postblit` and `postmove` methods.
Additionally, we need to sketch how a slice operation works and define
the destructors for these types.

Implementing Array Copy Initialization
**************************************

First, the `postblit` method will allocate new array elements and set
them to a copy of the original elements.

.. code-block:: chapel

  proc _array.postblit() {
    // at this point, _array's fields are already a bit copy
    // of the _array we are copy initializing from.

    // Allocate space for new array elements using the same
    // array size as the source array and copy the elements
    // into the new memory.
    _value = _value.clone();
  }

The `clone` method just creates a new array object and initializes it to
store a copy of the elements. Here is a complete `clone` method for
`SimpleArr`:

.. code-block:: chapel

  proc SimpleArr.clone() {
    // Allocate new array object
    var ret = new SimpleArr(eltType, n);
    // Allocate space for the elements
    ret.elements = _ddata_allocate(eltType, n); 
    // Bit copy the elements
    memcpy(ret.elements, this.elements, sizeof(int) * n);
    // Run the postblit fixup on the elements for non-POD record types
    if !isPODType(eltType) {
      for i in 0..#n {
        ret.elements[i].postblit();
      }
    }
  }

Implementing Array Move Initialization
**************************************

The `postmove` method will check `isalias`. If it is `true`, it will
create a full copy by running `postblit`. If it is `false`, it needs
not take any action.

.. code-block:: chapel

  proc _array.postmove() {
    // at this point, _array's fields are already a bit copy
    // of the _array we are move initializing from.

    // If isalias is true, create a full copy.
    if _value.isalias {
      this.postblit();
    }
  }

.. _record-copying-array-slices:

Implementing Array slices
*************************

The `isalias` field is generally `false` but set to `true` when a slice
is created. As we have seen, `postmove` for `_array` to copies the
element when `isalias` is `true`. To avoid this behavior when returning
from the function creating a slice, there is a special pragma to prevent
it from perfoming a move initialization as part of returning.  (Otherwise
the slice creation function would always create a copy!).

Here is a sketch of an implementation of dsiSlice for SimpleArray.
For simplicity we will assume that all slices start from element 0.

.. code-block:: chapel

  pragma "no move on return"
  proc _array.slice(newSize: int) {
    return new _array(_value.dsiSlice, isalias=true);
  }

  proc SimpleArray.dsiSlice(newSize: int) {
    // Create a new SimpleArray pointing to the same data
    // but with a different length
    return new SimpleArr(eltType, newSize, elements);
  }


Implementing _array Destruction
*******************************

Destruction for _array is simple - it just deletes the array object.

.. code-block:: chapel

  proc _array.deinit() {
    delete _value;
  }

Destruction for SimpleArr is still simple but it only destroys the
elements if isalias==false.

.. code-block:: chapel

  proc SimpleArr.deinit() {
    // Don't delete elements if isalias=true
    if ! isalias then
      delete elements;
  }

Relaxing lvalue checking for array temporaries
**********************************************

Because arrays frequently return by value, the compiler will need to
relax l-value checking when promoting a temporary _array to a `ref`. This
addresses the problem discussed above in
:ref:`record-copies-strawman-consume-return`.

The language specification would be updated to indicate that non-lvalues
of array type can be captured in a reference.

Changing what a ref to an array means
*************************************

The current compiler ignores the argument or return `ref` intent for
`_array` since it views `_array` as already being a reference to an array
object.

This proposal changes this behavior. Instead of viewing `_array` as
already being a reference, it treats a reference to an `_array` similarly
to a reference to any other record. (In implementation terms, a reference to
an array becomes `_ref(_array)`).

This is an implementation issue and does not impact the language
specification.


Example Array Programs
++++++++++++++++++++++

Now that we have defined `copy` and `move` initialization for arrays and
indicated how the compiler works with references to arrays, this section
discusses many example programs working with arrays in order to validate
that the design.

For each of these examples, we will point out when `copy` or `move`
initialization occur and discuss whether the proposed behavior is
different from the current behavior as implemented in Chapel v1.13.

Returning a Local Array
***********************

.. code-block:: chapel

   proc createArray() {
     var retA: [1..10000] real;
     return retA;
   }
   var A = createArray();

`retA` is an `_array`. In the process of returning from `createArray`, a
`move` initialization occurs. A second `move` initialization is used to
initializing the `A` variable and again does not perform a deep copy.
Thus, the desired behavior is achieved: the array is returned without any
copies.

The current implementation creates an `initCopy` call for the variable
initialization of `A` in this example.

Returning a Global Array with ref Return Intent
***********************************************

.. code-block:: chapel

   var globalArray: [1..10000] real;
   proc returnGlobalArray() ref {
     return globalArray;
   }
   var A = returnGlobalArray();

The process of returning from `returnGlobalArray` does not perform any
copy or move initialization since it returns with `ref` intent. However,
the variable initialization for `A` is using a ref and so is treated the
same as initialization from another variable. That results in a `copy`
operation. That gives in the desired semantics: `A` refers to a
different array than `outerA`.

The current implementation creates an `initCopy` call for the variable
initialization of `A` in this example.


Returning a Global Array
************************

.. code-block:: chapel

   var globalArray: [1..10000] real;
   proc returnGlobalArray() {
     return globalArray;
   }
   var A = returnGlobalArray();

The :ref:`automatic-ref-return` transformation applies to this example.
Since `returnGlobalArray` is returning a global, the transformation
applies. After that, this case is equivalent to the previous example.

Returning an argument
*********************

.. code-block:: chapel

  var A:[1..3] int;

  proc f(arg) {
    return arg; // copy created as part of returning
  }

  writeln(f(A));

As with the previous example, the :ref:`automatic-ref-return`
transformation applies to this example, and so it includes no `copy` or
`move` initializations.

The current behavior is for `f` to add an `autoCopy` in the process of
returning.


Passing a Returned Global Array
*******************************

.. code-block:: chapel

   var globalArray: [1..10000] real;
   proc returnGlobalArray() {
     return globalArray;
   }
   proc consumesArray(A:[] real) {
     writeln(A[1]);
   }
   consumesArray(returnExistingArray());

As with the above example, the :ref:`automatic-ref-return` transformation
applies. It makes this program equivalent to one where
`returnGlobalArray` is declared with `ref` return intent.
`returnExistingArray` does not create a copy in the process of returning
with the `ref` intent. Since the function `consumesArray` takes in `A` by
blank intent, which is `ref` for arrays, no copy is made when passing the
ref returned to that function. That gives the desired semantics: no copy
is added for this program.

The current behavior with this program is for `returnGlobalArray` to
include an `autoCopy`.

Passing a Returned Local Array
******************************

.. code-block:: chapel

   proc createArray() {
     var retA: [1..10000] real;
     return retA;
   }
   proc consumesArray(A:[] real) {
     writeln(A[1]);
   }
   consumesArray(createArray());

As we have previously discussed, the process of returning from
`createArray` would not create a copy. The call to `consumesArray` also
does not create a copy. Note that it would still not make a copy in this
case even if it had the `in` argument intent.  That gives the desired
result: no copy is necessary.

The current behavior with this snippet is that it does not produce an
`autoCopy` or `initCopy` calls.

Initializing a Record Field with an Array Argument
**************************************************

.. code-block:: chapel

   record RecordStoringArray{ var field; }
   proc createArray() {
     var retA: [1..10000] real;
     return retA;
   }
   proc consumesArray(A:[] real) {
     return new RecordStoringArray(A);
   }
   consumesArray(createArray());

As before, `createArray` does not call `copy` in the process of
returning. The value returned will be destroyed after the `consumesArray`
call. The call to `consumesArray` does not create a copy since it is
passing by reference. The initialization function for
`RecordStoringArray` initializes `field` field with another variable;
therefore a `copy` operation is included. That gives an acceptable
result: `retA` is copied into the record `field` as in the current
compiler.  (Note that it might be possible to eliminate this unnecessary
copy if `A` has `in` argument intent).

The current behavior is to generate an autoCopy and an initCopy of `A`
when initializing the record in this example.


Returning a Local Array with ref Return Intent
**********************************************

.. code-block:: chapel

  proc f() ref {
    var localArray:[1..100] int;
    return localArray; // error: returning local by ref
  }

  writeln(f()[1]);

This example should be a compilation error. Since returning with `ref`
intent has no impact on the lifetime of the returned variable,
`localArray` should continue to be destroyed when `f` exits, so that any
use of the data in the returned value would be a use-after-free.

The current behavior is to allow this program and to treat it the same
is if the `ref` return intent were not used on `f`.

Returning a Local or Global Array Based Upon Input
**************************************************

.. code-block:: chapel

  var A:[1..3] int;

  proc f(x:bool) {
    if x then return A;
    else {
      var tmp:[1..0] int;
      return tmp;
    }
  }
  proc g(x) {
    x[1] = 1;
  }
  g(f(true));
  writeln(A);

It produces `1 0 0` in the current implementation, but would produce `0 0 0`
under the proposal, because returning `A` from within `f` would make a copy.
The :ref:`automatic-ref-return` strategy cannot remove this copy since `f`
sometimes returns a local array (and it would not be legal to return the local
array by ref). (It might be reasonable to make such functions result in
a compilation error.)

Returning a Slice of a Local Array
**********************************

.. code-block:: chapel

  proc f() {
    var A:[1..4] int;
    return A[2..3];
  }

  var A_slice = f();
  writeln(A_slice);

This is the example discussed in  :ref:`record-copies-strawman-return-slice`.

The proposed strategy will have the slice construction function set
`isalias` to `true`, and then the `move` initialization made in the
process of returning in `f` will create a copy of the array slice. When
`f` completes, `A` and its elements will be freed.  Then, the copy of the
slide `move initialize` `A_slice`.

The current behavior adjusts reference counts when creating the slice and
uses an `initCopy` call to initialize `A_slice`.

Returning a Slice of a Global Array
***********************************

.. code-block:: chapel

  var A:[1..4] int;

  proc f() {
    return A[2..3];
  }

  proc g(x) {
    x[2] = 1;
  }

  g(f());
  writeln(A);

Currently (in v1.13) outputs `0 1 0 0`. Under the proposal, it would
output `0 0 0 0` because the `return` from `f` causes a `move
initialization` in which `isalias` is true, resulting in a copy of the
elements.

This proposal does not include a user-facing way to manually restore the
old behavior. Note though that the slice function uses a pragma that
could possibly be generalized into a user-facing feature.

Initializing a Variable with a Slice
************************************

.. code-block:: chapel

  var A:[1..4] int;
  var A_slice = A[2..3];
  A_slice[2] = 1;
  writeln(A);

Currently outputs `0 0 0 0`. Will still do that because `move` for array
slice from variable initialization will detect `isalias` and perform a
full copy.

Initializing a Variable to Refer to a Slice
*******************************************

.. code-block:: chapel

  var A:[1..4] int;
  var A_slice => A[2..3];
  A_slice[2] = 1;
  writeln(A);

Currently outputs `0 1 0 0`. It can still do that if `=>` is not
considered normal variable initialization, but more like `ref`
initialization.

Returning a Slice from a Function By Ref
****************************************

.. code-block:: chapel

  var A:[1..4] int;
  var A_slice => A[2..3];
  proc f() ref {
    return A_slice;
  }

  f() = 1;
  writeln(A);

Currently outputs `0 1 1 0`. It will continue to do so under this proposal,
since `copy` and `move` for `_array` are not called when returning by ref.

It should be possible to create a `ref` to the temporary `_array` record
returned by a function. Therefore, this example could also be written:

.. code-block:: chapel

  var A:[1..4] int;
  ref A_slice = A[2..3];
  proc f() ref {
    return A_slice;
  }

  f() = 1;
  writeln(A);


Returning a Slice with ref Intent
*********************************

.. code-block:: chapel

  proc f() ref {
    var A:[1..4] int;
    return A[2..3];
  }

  writeln(f());

Currently (v1.13) outputs `0 0`. It should be a compile error under the
proposal, since it returns a local (temporary) variable by `ref`.



